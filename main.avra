.include "defines.avra"
.include "jumptable.avra"
.CSEG
.org 0x36                       ;after jump table + default int. handler
_start:
        eor r1, r1
        out SREG, r1        ;zero SREG
        ldi r28, 0xFF
        ldi r29, 0x08
        out 0x3e, r29       ;init SPH (stack pointer high) (i think)
        out 0x3d, r28       ;init SPL (stack pointer low)
        call main
        jmp _exit

;r18, sreg
setup:
        ldi r18, 0x02
        out TCCR0A, r18         ;set TCCR0A to 0b00000010 (wgm01 high) (clear on ocr0a match)
        ldi r18, 0x05
        out TCCR0B, r18         ;set prescaler to 0b101 (clk/1024)
        ldi r18, 0x06
        sts TIMSK0, r18         ;set output compare intr. enable A and B
        ldi r18, 0xFF
        out OCR0A, r18          ;set out match for 0xFF
        out OCR0B, r18          ;set another match for other match register
        ret


main:
        call setup

        ldi r24, 0x00           ;btn 1 software debounce (pb0)
        ldi r26, 0x00           ;btn 2 software debounce (pc5)
        ldi r18, 0x01
        ldi r19, 0x06
        out DDRB, r19           ;set pin PB1 & PB2 to output
        out PORTB, r18          ;set pb0 to pullup
        nop
        ldi r18, 0x20
        out DDRC, r24           ;set all pins to input
        out PORTC, r18          ;PC5 to pullup
        ldi r19, 0x02           ;r19 will store ports that will be output (default just pb1) pull up should NOT be toggled
        nop                     ;for synchronization
        sei

while:
        eor r25, r25
        in r25, PINB            ;read pb
        andi r25, 0x1
        breq PB2_toggle         ;toggle pb2 if button pressed

        cli                     ;only read pinc if light is set to off state
        mov r25, r19
        andi r25, 0x04
        sei
        brne while

        in r25, PINC            ;read pc
        andi r25, 0x20          ;0b100000
        breq PB2_ON
        jmp PB2_OFF
        jmp while

;sreg
PB2_OFF:
        cli
        push r24
        in r24, PORTB
        andi r24, 0xfb          ;0b11111011
        out PORTB, r24
        pop r24
        sei
        jmp while
;sreg
PB2_ON:
        cpi r26, 0
        brne while
        cli
        push r24
        in r24, PORTB
        ori r24, 0x04
        out PORTB, r24
        ldi r26, 1
        pop r24
        sei
        jmp while

;sreg, r24, r19
PB2_toggle:
        cli
        cpi r24, 0              ;is debnce reg 0?
        brne end                ;then skip toggle
        ldi r24, 2              ;wait two flash cycles before allowing to toggle again
        push r20
        push r21
        ldi r20, 0x04
        eor r19, r20            ;toggle pb2

        ;if pb2 is to be off next cycle, make sure it doesn't get "aligned" to on state
        mov r20, r19
        andi r20, 0x04
        breq force_off

        ;this section will "join" the current driving led
        in r20, PORTB           ;read in current value of portb
        mov r21, r20            ;copy portb to r21
        andi r20, 0x02           ;iso bit 1 (2nd bit)
        lsl r20                 ;shift bit 1 to bit 2 pos.
        or r21, r20             ;if portb is 0b011 -> 0b111 and if portb is 0b001 -> 0b001. Keeps lights aligned
        jmp output_aligned

force_off:
        ldi r21, 0x03           ;hardcode pb0 and pb1 to be high and pb2 to be low

output_aligned:
        out PORTB, r21          ;output aligned lights
        pop r21
        pop r20
end:
        sei
        jmp while


debounce_timer:
        push r16
        in r16, SREG
        push r16

;debounces decr btn 2
        cpi r26, 0              ;r26 contains btn 2 debounce info
        breq debounce_btn_one
        dec r26

;same thing but for btn 1
debounce_btn_one:
        cpi r24, 0              ;is debnce reg 0?
        breq debounce_timer_end ;then don't decr debnce reg
        dec r24                 ;otherwise decr debnce reg

debounce_timer_end:
        pop r16
        out SREG, r16
        pop r16
        reti

;int handler to eor portb with whatever is in r19
flash_lights:
        push r16
        in r16, SREG
        push r16
        push r18

        in r18, PORTB
        eor r18, r19
        out PORTB, r18
        pop r18

        pop r16
        out SREG, r16
        pop r16
        reti

_exit:
        cli
